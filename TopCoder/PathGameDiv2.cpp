#include <bits/stdc++.h>
using namespace std;

const char B = '#';
const char W = '.';

struct state {
  int x, y, c;
  state() { }
  state(const int x, const int y, const int c)
    : x(x), y(y), c(c) { }
};

class PathGameDiv2 {
public:
  int solve(const int sx, const int sy, const vector<string>& b) {
    const int n = b.size();
    const int m = b[0].length();

    if (b[sx][sy] == B)
      return numeric_limits<int>::max() / 2;

    auto ok = [&](const int x, const int y) {
      return x >= 0 && x < n && y >= 0 && y < m && b[x][y] != B;
    };

    bool visited[2][55] = { false };
    visited[sx][sy] = true;

    queue<state> q;
    for (q.push(state(sx, sy, 1)); !q.empty(); q.pop()) {
      const state s = q.front();

      if (s.y == m - 1)
        return s.c;

      if (ok(s.x, s.y + 1) && !visited[s.x][s.y + 1]) {
      	q.push(state(s.x, s.y + 1, s.c + 1));
      	visited[s.x][s.y + 1] = true;
      }
      if (ok(s.x + 1, s.y)) {
      	if (!visited[s.x + 1][s.y]) {
      	  q.push(state(s.x + 1, s.y, s.c + 1));
      	  visited[s.x + 1][s.y] = true;
      	}
      }
      if (ok(s.x - 1, s.y)) {
      	if (!visited[s.x - 1][s.y]) {
      	  q.push(state(s.x - 1, s.y, s.c + 1));
      	  visited[s.x - 1][s.y] = true;
      	}
      }
    }
    return numeric_limits<int>::max() / 2;
  }
  
  int calc(vector<string> board) {
    int empty = 0;
    for (string str : board) empty += count(str.begin(), str.end(), W);
    return empty - min(solve(0, 0, board), solve(1, 0, board));
  }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << "\"" << p0[i] << "\"";
  }
  cout << "}";
  cout << "]" << endl;
  PathGameDiv2 *obj;
  int answer;
  obj = new PathGameDiv2();
  clock_t startTime = clock();
  answer = obj->calc(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p1 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p1;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;
	
  vector <string> p0;
  int p1;
	
  {
    // ----- test 0 -----
    string t0[] = {"#....","...#."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 2;
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 1 -----
    string t0[] = {"#","."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 0;
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 2 -----
    string t0[] = {".","."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 1;
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 3 -----
    string t0[] = {"....#.##.....#...........","..#......#.......#..#...."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 13;
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }
	
  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
